#version 330 core

struct PointLight {
    vec3 position;
    vec3 color;
    float strength;
}; 

in vec2 fragmentTexCoord;
in vec3 fragmentPosition;
in vec3 fragmentNormal;

out vec4 color;

uniform sampler2D imageTexture;
uniform PointLight Light;
uniform vec3 viewPos; 

// NEW UNIFORMS
uniform int useTexture;    // 1 = Use Texture, 0 = Use Solid Color
uniform vec3 objectColor;  // The solid color to use if useTexture is 0

vec3 calculatePointLight(PointLight light, vec3 fragPos, vec3 fragNorm, vec3 viewPos);

void main()
{
    vec3 temp = calculatePointLight(Light, fragmentPosition, normalize(fragmentNormal), viewPos);
    color = vec4(temp, 1.0);
}

vec3 calculatePointLight(PointLight light, vec3 fragPos, vec3 fragNorm, vec3 viewPos) {
    
    // --- SWITCH LOGIC HERE ---
    vec3 baseTexture;
    if (useTexture == 1) {
        baseTexture = texture(imageTexture, fragmentTexCoord).rgb;
    } else {
        baseTexture = objectColor;
    }
    // -------------------------
    
    // 1. Ambient
    vec3 ambient = 0.1 * baseTexture; 

    // 2. Diffuse
    vec3 lightDir = normalize(light.position - fragPos);
    float diff = max(dot(fragNorm, lightDir), 0.0);
    vec3 diffuse = diff * light.color * light.strength * baseTexture;

    // 3. Specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - fragPos);
    vec3 reflectDir = reflect(-lightDir, fragNorm); 
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * light.color;  

    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (1.0 + 0.1 * distance + 0.01 * distance * distance);

    return (ambient + diffuse + specular) * attenuation;
}